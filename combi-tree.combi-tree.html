<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>combi-tree.combi-tree documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Combi-tree 0.1.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>combi-tree</span></div></div></li><li class="depth-2 current"><a href="combi-tree.combi-tree.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>combi-tree</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="combi-tree.combi-tree.html#var-combinations"><div class="inner"><span>combinations</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-combinations-tree"><div class="inner"><span>combinations-tree</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-combinations-zip"><div class="inner"><span>combinations-zip</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-distinct-combinations"><div class="inner"><span>distinct-combinations</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-distinct-combinations-tree"><div class="inner"><span>distinct-combinations-tree</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-empty-tree-list"><div class="inner"><span>empty-tree-list</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-prefix-tree"><div class="inner"><span>prefix-tree</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-tree-.3Ecombinations"><div class="inner"><span>tree-&gt;combinations</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-tree-conj"><div class="inner"><span>tree-conj</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-tree-cons"><div class="inner"><span>tree-cons</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-tree-list"><div class="inner"><span>tree-list</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-tree-rest"><div class="inner"><span>tree-rest</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-tree-seq.3F"><div class="inner"><span>tree-seq?</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-unique-combinations"><div class="inner"><span>unique-combinations</span></div></a></li><li class="depth-1"><a href="combi-tree.combi-tree.html#var-with-tree-meta"><div class="inner"><span>with-tree-meta</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">combi-tree.combi-tree</h2><div class="doc"><pre class="plaintext">Combinatorics functions based on building a combination tree.
</pre></div><div class="public anchor" id="var-combinations"><h3>combinations</h3><div class="usage"><code>(combinations tree)</code><code>(combinations coll n)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of all the unique ways of taking n different elements
from a sequence (i.e. elements at n distinct positions in the sequence) while
preserving their original order. The same combination may be returned multiple
times if coll contains duplicates.
Returns &apos;(()) if n is 0.
This function also takes a single combinations tree, thus deriving all
combinations the tree can yield. The given tree can be the the result of
combinations-tree or distinct-combinations-tree. In the first case duplicates
may appear if the original collection contains duplicates. In the latter case
only distinct combinations will be returned (no duplicates).
Returns nil if no combinations exists, if tree or coll is nil or empty,
or if n is 0.
Throws the same exceptions as combinations-tree.
Throws an exception when n is negative or greater than the size of coll.
With 2 args this returns what clojure.math.combinatorics/combinations returns
except when n=0 where it returns nil instead of &apos;(()).</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L243">view source</a></div></div><div class="public anchor" id="var-combinations-tree"><h3>combinations-tree</h3><div class="usage"><code>(combinations-tree coll)</code><code>(combinations-tree coll n)</code></div><div class="doc"><pre class="plaintext">Returns nested and mostly lazy sequences representing a tree of all the
unique ways of taking n different elements from a sequence (i.e. elements at
n distinct positions in the sequence) while preserving their original order.
A branch in the tree is a sequence of at least 2 items, the first being
the node and the rest being the children of that node. Nodes and leafs are
items of the original collection so that each path in the tree provides a
possible combination. The result of this function is a sequence of root
children, meaning there is no root node in the first position.
If the original collection contains duplicates, the resulting combinations
will also contain duplicates. Use distinct-combinations-tree to get a tree
that yields no duplicates.
Examples:
  (combinations-tree [:k :s :k :s] 2)
  =&gt; ((:k :s :k :s) (:s :k :s) (:k :s))
  (combinations-tree [:k :s :k :s] 3)
  =&gt; ((:k (:s :k :s) (:k :s)) (:s (:k :s)))
When only coll is provided as argument, this function returns a map of
all combinations trees indexed by their size:
  (combinations-tree [:k :s :k :s])
  =&gt; {0 ()
      1 (:k :s :k :s), 
      2 ((:k :s :k :s) (:s :k :s) (:k :s)), 
      3 ((:k (:s :k :s) (:k :s)) (:s (:k :s))), 
      4 ((:k (:s (:k :s))))}
Returns nil if n is 0 or greater than the size of coll.
Throws an exception if n is negative or nil.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L72">view source</a></div></div><div class="public anchor" id="var-combinations-zip"><h3>combinations-zip</h3><div class="usage"><code>(combinations-zip combinations-tree)</code></div><div class="doc"><pre class="plaintext">Returns a clojure.zip zipper on a given combinations tree. Operates on the
result of combinations-tree or distinct-combinations-tree. Note that because
combination trees have no root node, a dummy nil root node is added to the
tree passed as argument so that a zipper can be built with it.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L206">view source</a></div></div><div class="public anchor" id="var-distinct-combinations"><h3>distinct-combinations</h3><div class="usage"><code>(distinct-combinations coll n)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of all the unique ways of taking n different elements
from a sequence (i.e. elements at n distinct positions in the sequence) while
preserving their original order. A combination is returned only once even if
coll contains duplicates.
Returns nil if no combinations exists, if tree or coll is nil or empty,
or if n is 0.
Throws the same exceptions as combinations-tree.
Throws an exception when n is negative or greater than the size of coll.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L265">view source</a></div></div><div class="public anchor" id="var-distinct-combinations-tree"><h3>distinct-combinations-tree</h3><div class="usage"><code>(distinct-combinations-tree coll-or-combinations-tree)</code><code>(distinct-combinations-tree coll n)</code></div><div class="doc"><pre class="plaintext">Same as combinations-tree, except that trees corresponding to duplicate
combinations are merged into a single path terminating by a ::dups leaf.
This function can accept a single parameter, which can either be a collection
for which combinations tree must be computed, or a tree as returned by
combinations-tree which must satisfy tree-seq?.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L138">view source</a></div></div><div class="public anchor" id="var-empty-tree-list"><h3>empty-tree-list</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L34">view source</a></div></div><div class="public anchor" id="var-prefix-tree"><h3>prefix-tree</h3><div class="usage"><code>(prefix-tree heads tree)</code></div><div class="doc"><pre class="plaintext">Adds a sequence of items to the head of a given tree, returning a new tree
that yields sequences starting with the sequence of items. For example:
(combinations (prefix-tree [1 2] (combinations-tree [3 4 5 6] 2)))
=&gt; ((1 2 3 4) (1 2 3 5) (1 2 3 6) (1 2 4 5) (1 2 4 6) (1 2 5 6))</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L300">view source</a></div></div><div class="public anchor" id="var-tree-.3Ecombinations"><h3>tree-&gt;combinations</h3><div class="usage"><code>(tree-&gt;combinations tree)</code><code>(tree-&gt;combinations tree remove-dups?)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of the combinations derived from a tree as returned
by combinations-tree or distinct-combinations-tree. An optional boolean
indicates if the result should include combinations derived from paths 
terminating by ::dups.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L218">view source</a></div></div><div class="public anchor" id="var-tree-conj"><h3>tree-conj</h3><div class="usage"><code>(tree-conj coll x)</code><code>(tree-conj coll x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Add a marker meta-data to the result of calling conj on the given arguments.
Used in combination trees to distinguishing sequences that are part of the
tree structure from sequences that are node values.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L61">view source</a></div></div><div class="public anchor" id="var-tree-cons"><h3>tree-cons</h3><div class="usage"><code>(tree-cons x seq)</code></div><div class="doc"><pre class="plaintext">Creates a cons with a marker meta-data and containing the given elements.
Used in combination trees to distinguish sequences that are part of the
tree structure from sequences that are node values.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L44">view source</a></div></div><div class="public anchor" id="var-tree-list"><h3>tree-list</h3><div class="usage"><code>(tree-list &amp; elements)</code></div><div class="doc"><pre class="plaintext">Creates a list with a marker meta-data and containing the given elements.
Used in combination trees to distinguish sequences that are part of the
tree structure from sequences that are node values.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L35">view source</a></div></div><div class="public anchor" id="var-tree-rest"><h3>tree-rest</h3><div class="usage"><code>(tree-rest coll)</code></div><div class="doc"><pre class="plaintext">Returns the rest of the given coll with a marker meta-data.
Used in combination trees to distinguish sequences that are part of the
tree structure from sequences that are node values.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L51">view source</a></div></div><div class="public anchor" id="var-tree-seq.3F"><h3>tree-seq?</h3><div class="usage"><code>(tree-seq? o)</code></div><div class="doc"><pre class="plaintext">Returns true if the given object is a seq with a ::tree meta-data.
</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L29">view source</a></div></div><div class="public anchor" id="var-unique-combinations"><h3>unique-combinations</h3><div class="usage"><code>(unique-combinations distinct-combinations-tree)</code><code>(unique-combinations coll n)</code></div><div class="doc"><pre class="plaintext">Computes all unique combinations of n different elements taken from a
sequence (i.e. elements at n distinct positions in the sequence) while
preserving their original order.
When a coll and a single integer is provided, this function returns a sequence
of all combinations of n elements from coll:
  (unique-combinations [:k :s :k :s] 2)
  =&gt; ((:s :k) (:s :s) (:k :k))
When coll contains duplicates, the set of all possible combinations may also
contain duplicates which are eliminated from the results of this function as
they are not unique. In the above example the (:k :s) combination has been
removed for that reason because it matches positions 1+2 and 3+4.
When duplicates are not be be removed, use the combinations function instead.
This function also takes a single tree as returned by distinct-combinations-tree
thus deriving all unique combinations the tree can yield.
Returns nil if no combinations exists, if tree or coll is nil or empty,
or if n is 0.
Throws the same exceptions as distinct-combinations-tree.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L277">view source</a></div></div><div class="public anchor" id="var-with-tree-meta"><h3>with-tree-meta</h3><div class="usage"><code>(with-tree-meta obj)</code><code>(with-tree-meta obj m)</code></div><div class="doc"><pre class="plaintext">Returns obj as a list with ::tree meta-data set to nil.
An optional meta data map can be passed to be added as well.</pre></div><div class="src-link"><a href="http://github.com/fmjrey/combi-tree/blob/master/src/cljx/combi_tree/combi_tree.cljx#L11">view source</a></div></div></div></body></html>